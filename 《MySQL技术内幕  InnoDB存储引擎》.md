# 第6章 锁

一个开发难点：利用数据库的并发访问，同时又要确保一致性读与写。数据库系统区别于文件系统的关进特性。

人们认为行级锁总会增加开销，实际上，只有当实现本身会增加开销时，行级锁才会增加开销。InnoDB不需要锁升级，因为一个锁和多个锁的开销时相同的。

## 6.1 什么是锁？

锁机制用于管理对共享资源的并发访问。不只是行级锁，同时会在内部其他地方使用锁。例如操作缓冲池LRU列表。

数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

不同数据库实现对于锁的实现不同。

MyISAM引擎是表锁设计。并发情况下读没有问题，但是并发插入的性能差一些。

InnoDB存储引擎，提供一致性的非锁定读、行级锁支持。行级锁没有额外的开销，并可以同时得到并发性和一致性。

## 6.2 lock和latch

都可以被称为“锁”，但含义不同。这里主要说lock。

latch分为mutex（互斥锁）和rwlock（读写锁）。其目的是用来保证并发线程操作资源的正确性，没有死锁检测机制。

lock的对象是事务，锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit和rollback后进行释放（不同隔离级别释放时间不同）。有死锁机制。

查看latch的命令：SHOW ENGINE INNODE MUTEX;

## 6.3 InnoDB存储引擎中的锁

### 6.3.1 锁的类型

两种标准类型的**行级锁**：

- 共享锁（S Lock）
- 排他锁（X Lock）

X锁与任何的锁都不兼容，S锁仅与S锁兼容。

InnoDB存储引擎支持多粒度锁定，允许行级锁和表级锁同时存在。为了支持不同粒度上加锁，InnoDB支持了一种额外的锁方式，意向锁（Intention Lock）。

意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望再更细力度上进行加锁。

即先用意向锁锁粗粒度，最后用行级锁锁住行。

- 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。
- 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。

InnoDB支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。

![1567084311609](assets/1567084311609.png)

lock_data不可信。当用户运行一个范围查找时，lock_data只返回第一行的主键值。

### 6.3.2 一致性非锁定读

一致性非锁定读是指InnoDB通过多版本控制的方式来读取当前执行时间数据库中行的数据。

如果读取的行正在执行DELETE或UPDATE操作，这是读取操作不会因此去等待行上锁的释放。而是去读取行的一个快照数据。

非锁定是因为不需要等待X锁地释放。快照通过undo实现，没有额外开销。而且读快照不需要上锁。

RC和RR下，InnoDB使用非锁定地一致性读。但对快照地定义不同。

RC违反了隔离性。

### 6.3.3 一致性锁定读

两种一致性锁定读操作：

- SELECT ... FOR UPDATE;
- SELECT ... LOCK IN SHARE MODE;

SELECT ... FOR UPDATE;对读取地行记录加一个X锁，其他事务不能对已锁定地行加上任何锁。

SELECT ... LOCK IN SHARE MODE;对读取的行记录加一个S锁，其他事务可以向被锁定的行加S锁，但是如果加X会被阻塞。

事务提交时锁就释放了。

### 6.3.4 自增长与锁

再InnoDB的内存结构中，对每个含有自增长值得表都有一个自增长计数器。当对含有自增长技术器得表进行插入操作时，这个计数器会被初始化，执行如下得语句来得到计数器的值：

SELECT MAX(auto_inc_col) FROM t FOR UPDATE;

插入操作将其加1。这个实现风湿称作AUTO-INC Locking。这种锁其实是采用一种特殊得表锁机制，为了提高插入得性能，锁不在事务完成后释放，而是完成对自增长得SQL语句后立即释放。

虽然AUTO-INC Locking从一定程度上提高了并发插入得效率，但还是有性能问题。事务必须等待前一个插入的完成。其次对于INSERT...SELECT 的大数量的插入会影响插入的性能，因为另一个事务中的插入会被阻塞。

=========

5.1.22之后对这部分进行了一个优化：提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长插入的性能。

并且从该版本开始，InnoDB存储引擎提供了一个参数innodb_autonic_lock_mode来控制自增长，默认值为1。

自增长的插入分类图：

![1567087007266](assets/1567087007266.png)

innodb_autoinc_lock_mode各个设置下对自增的影响：

![1567087055534](assets/1567087055534.png)

特别注意：InnoDB的自增长实现与与MyISAM不同，MyISAM存储引擎是表锁设计，自增长不用考虑并发插入的问题。

在InnoDB中，自增长值得列必须是索引，同时**必须**是索引得第一个列。

### 6.3.5 外键和锁

## 6.4 锁的算法

### 6.4.1 行锁的3种算法

- Record Lock：单个行记录上的锁
- GapLock：间隙锁，锁定一个范围，但**不包含**记录本身
- Next-Key Lock：Record Lock + GapLock，锁定一个范围并且锁定记录本身。

Record Lock总是会去锁住**索引记录**，如果建表时没有设置索引，则会使用隐式的主键来进行锁定。

