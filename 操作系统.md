# 概述
## 一、基本特征

### 并发

并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。

并发的基础：进程和线程

### 共享

系统中的资源可以被多个并发进程共同使用。

两种方式：互斥共享和同时共享。

### 虚拟

把一个物理实体转换为多个逻辑实体。

两种主要技术：

- 时分复用技术——时间片轮转

- 空分复用技术——虚拟内存（？）：把物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

### 异步

指进程不是一次性执行完毕

## 二、基本功能

### 进程管理

进程控制、进程同步、进程通信、死锁处理、处理机调度等。

### 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

### 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

### 设备管理

完成用户的I/O请求，方便用户使用各种设备，并提高设备的利用率。

缓冲管理、设备分配、设备处理、虚拟设备等。

## 三、系统调用

如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。

## 四、大内核和微内核

### 大内核

将操作系统功能作为一个紧密结合的整体放到内核。

由于各模块共享信息，因此有很高的性能。

### 微内核

只有微内核这一个模块运行在内核态，其余模块运行在用户态。

因为需要频繁地在用户态和核心态之间进行切换，所以会有一定地性能损失。

## 五、中断分类

### 外中断

由CPU1执行指令以外的事件引起，I/O完成中断、时钟中断、控制台中断等。

### 异常

由CPU执行指令的内部事件引起，如非法操作码，地址越界、算术溢出等。

### 陷入

在用户程序中使用系统调用。

---

# 进程管理
## 一、进程与线程

### 1.进程

资源分配的基本单位。

**进程控制块（Process Control Block,PCB）**描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是对PCB的操作。

### 2.线程

独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

### 3.区别

1. 拥有资源：线程不拥有资源，线程可以访问隶属进程的资源。
2. 调度：同意进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
3. 系统开销：创建、撤销或切换的开销，进程都大于线程。
4. 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是线程通信需要借助IPC（Inter-Process Communication 进程间通信）。

## 二、进程状态的切换

三种状态：

- 就绪状态（ready）：等待被调度
- 运行状态（running）
- 阻塞状态（waiting）：等待资源

## 三、进程调度算法

### 批处理系统

没有太多的用户操作，调度算法的目标时保证吞吐量和周转事件（从提交到终止的事件）。

#### 1.先来先服务 first-come first-serverd(FCFS)

按照请求的顺序进行调度。

有利于长作业，不利于短作业。

#### 2.短作业优先 shortest job first(SJF)

按估计运行时间最短的顺序进行调度。

长作业可能饿死。

#### 3.最短剩余时间优先 shortest remaining time next(SRTN)

按估计剩余时间最短的顺序进行调度。

### 交互式系统

有大量的用户操作，调度算法的目标是快速地进行响应。

#### 1.时间片轮转

按FCFS的原则排成一个队列...

效率与时间片大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上会花过多的时间。
- 如果时间片过长，那么实时性就不能得到保证。

#### 2.优先级调度

为每个进程分配一个优先级，按优先级调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

#### 3.多级反馈队列

一个进程需要执行100个时间片，如果采用时间片轮转调度算法，那么需要交换100次。

设置了多个队列，每个队列时间片大小都不同，例如1，2，4，8...

进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换7次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法与优先级调度算法的结合。

### 实时系统

要求一个请求在一个确定时间内得到响应。

硬实时：满足绝对的截至时间

软实时：可以容忍一定的超时

## 四、进程同步

### 临界区

对临界资源进行访问的那段代码称为临界区。

为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

### 同步与互斥

- 同步：多个进程按一定顺序执行；
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

### 1.信号量

一个整型变量，可以对其执行down和up操作，也就是常见的P和V操作。

### 2.管程

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也是的客户端代码调用更容易。





## 五、进程通信

进程同步与进程通信的区别：

- 进程同步：控制多个进程按一定顺序执行
- 进程通信：进程间传输信息

进程通信是一种手段，进程同步是一种目的。为了达到能够进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

### 1.管道

通过调用pipe函数创建的，fd[0]用于读，fd[1]

```C
#include <unistd.h>
int pipe(int fd[2]);
```

具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程中使用。

### 2.FIFO

也称为命名管道，去除了管道只能在父子进程中使用的限制。

FIFO常用于客户端-服务器应用程序中，FIFO用作汇聚点，在客户进程和服务器进程之间传递数据。

### 3.消息队列

相比与FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了FIFO中同步管道的打开和关闭时可能产生的困难；
- 避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接受消息，而不像FIFO那样只能默认地接收。

### 4.信号量

一个计数器，用于为多个进程提供对共享数据对象的访问。

### 5.共享存储

允许多个进程共享一个给定的存储出。因为数据不需要在进程之间复制，所以这是最快的一种IPC。

需要使用信号量用来同步对共享存储的访问。

多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外XSI共享内存不是使用文件，而是使用内存的匿名段。

### 6.套接字

与其它通信机制不同的是，它可用于不同机器间的进程通信。

---

# 死锁

## 一、必要条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的，也就是说资源必须是**临界资源**
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源；
- 不可抢占：已经分配给了一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放；
- 环路等待：有两个或者两个以上地进程组成一条环路，该环路中地每个进程都在等待下一个进程所占有的资源。

## 二、处理方法

### 鸵鸟策略

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

大多数操作系统，包括Unix，Linux和Windows，处理死锁问题的办法仅仅是忽略它。

### 死锁检测与死锁恢复

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

主要有两种死锁检测：超时机制和检测是否存咋环路。

在检测到发生死锁之后，可以使用进程回退或者事务回滚等机制，释放获取的资源，之后再重新执行。

InnoDB存储引擎使用检测是否存在环路的方式，并且选择将回滚操作代价小的事务进行回滚。

#### 1.每种类型一个资源的死锁检测

通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

#### 2.每种类型多个资源的死锁检测

每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。

1. 寻找一个没有标记的进程Pi，它所请求的资源小于等于A。
2. 如果找到了这样一个进程，那么将C矩阵的第i行向量加到A中，标记该进程，并转回1。
3. 如果没有这样一个进程，算法终止。

### 死锁预防

在程序运行之前通过某些手段保证不发生死锁。

#### 1.破坏互斥条件

临界资源需要互斥访问，所以基本不能破坏互斥条件。但也可以使用一些手段来使得多个进程可以用共享的方式去使用临界资源。

#### 2.破坏占有和等待条件

规定所有进程在开始执行前一次性获取全部资源。

会增加开销，是的并发程度变低。

#### 3.破坏不可抢占条件

规定进程在请求资源失败时，释放它获得的所有资源。

#### 4.破坏环路等待

给资源统一编号，进程只能按编号顺序来请求资源。但有些资源本身不具有编号属性，如果加上编号的话，那么会让程序逻辑变得复杂。

### 死锁避免

在**程序运行时**避免发生死锁

#### 1.安全状态

如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。

安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与四速检测算法非常类似，可以结合着做参考对比。

#### 2. 单个资源的银行家算法

判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。

#### 3.多个资源的银行家算法

## 三、活锁与饥饿

- 活锁 ：是指进程互相谦让，都释放资源给别的进程，导致资源再进程之间跳动但是进程却一直不知心。

- 饥饿：是指将低优先级的进程长时间请求不到所需要的资源。但是饥饿中进程最后可以请求到资源，只要不再有高优先级的进程使用资源，这和死锁有所不同。

# 内存管理

## 一、虚拟内存

目的：为了让物理存储扩充到更大的逻辑内存，从而绕过程序获得更多的可用地址。

## 二、分页系统地址映射

内存管理单元（MIMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

