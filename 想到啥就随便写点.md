

# 激活Office

用VPN连校园网后输入

```shell
cscript "c:\Program Files\Microsoft Office\Office16\ospp.vbs" /sethst:202.115.128.81
cscript "c:\Program Files\Microsoft Office\Office16\ospp.vbs" /act
```



# JAVA注解(Annotation)

> Java注解用于为Java代码提供元数据。作为元数据，注解不直接影响你的代码执行，但也有一些类型的注解实际上可以用于这一目的。Java注解是从Java5开始添加到Java的。

同class和interface一样，注解也属于一种类型。

## 注解定义

```java
public @interface TestAnnotation {
}
```

## 注解的应用

```JAVA
@TestAnnotation
public class Test {
}
```

## 元注解

可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其他的注解上面。

5种元注解：

1. @Retention
2. @Docution
3. @Target
4. @Inherited
5. @Repeatable

### @Retention

英文意思：保留期。用于注解上，解释说明了注解的存活时间。

它的取值如下：
- RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。
- RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。
- RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。

```JAVA
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {
}
```

### @Documented

与文档有关。作用是将注解中的的元素包含到javadoc中去。

### @Target

英文意思：目标。指定注解运用的地方。

有以下取值：
- ElementType.ANNOTATION_TYPE 可以给一个注解进行注解
- ElementType.CONSTRUCTOR 可以给构造方法进行注解
- ElementType.FIELD 可以给属性进行注解
- ElementType.LOCAL_VARIABLE 可以给局部变量进行注解
- ElementType.METHOD 可以给方法进行注解
- ElementType.PACKAGE 可以给一个包进行注解
- ElementType.PARAMETER 可以给一个方法内的参数进行注解
- ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举

### @Inherited

英文意思：继承。如果一个超类被@Inherited注解过的注解进行注解，而且它的子类没有被任何注解应用，那么这个子类就继承了超类的注解。

### @Repeatable

英文意思：可重复的。JDK1.8的新特性。

```JAVA
@interface Persons {
	Person[] value();
}

@Repeatable(Person.class)
@interface Person{
	String role defalut "";
}

@Person(role="artist")
@Person(role="coder")
@Person(role="PM")
public class SUperman {

}
```



## 注解的属性

注解的属性也叫做成员变量。只有成员变量，没有方法。

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnntation {
	int id();
	String msg();
}
```

使用的时候赋值：

```JAVa
@TestAnnotation(id=3,msg="hello annotation")
public class Test {
}
```

**注解中的属性类型必须是8中基本数据类型外加类、接口、注解及它们的数组**

default定义注解中属性的默认值：

```JAVA
@Target(ElimentType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {
	
	public int id() default -1;
	
	public String msg() default "Hi";
}
```
## Java预置的注解

### @Deprecated

用以标记过时的元素。

### @Override

提示子类要重写父类中被@Override修饰的方法

### @SuppressWarnings

英文意思：阻止编译器进行警告提醒。

### @SafeVarargs

参数安全类型注解。JDK1.7新增特性。

### @Functionalinterface

函数时接口注解，JDK1.8新增特性。

## 注解的提取

检阅注解——反射。

### 注解与反射

首先，通过Class对象的isAnnotationPresent()方法判断是否应用了某个注解

```JAVA
public boolean isAnnotationPresent(Class<? extens Annotation> annotationClass) {}
```

然后，通过getAnnotation()方法来获取Annotationd对象。

```JAVA
public <A extens Annotation> A getAnnotation(Class<A> annotationClass) {}
```

或者是getAnnotations()方法。

```JAVA
public Annotation[] getAnnotations() {}
```

前一种方法返回指定类型的注解，后一种方法返回注解到这个元素上的所有注解。

如果获取到的Annotetion如果不为null，则就可以调用它们的属性方法。比如

```
@TestAnnotation()
public class Test {
	
	public static void main(String[] args) {
		boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);
	
		if(hasAnnotation) {
			TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
			
			System.out.peintln("id:"+testAnnotation.id());
			System.out.println("msg:"+testAnnotation.msg());
		}
	}	
}
```

运行结果：

```JAVA
id:-1
msg:
```

属性方法上的注解：

```java
@TestAnnotation(msg="hello")
public class Test {
	
	@Check(value="hi")
	int a;
	
	
	@Perform
	public void testMethod(){}
	
	
	@SuppressWarnings("deprecation")
	public void test1(){
		Hero hero = new Hero();
		hero.say();
		hero.speak();
	}


	public static void main(String[] args) {
		
		boolean hasAnnotation = Test.class.isAnnotationPresent(TestAnnotation.class);
		
		if ( hasAnnotation ) {
			TestAnnotation testAnnotation = Test.class.getAnnotation(TestAnnotation.class);
			//获取类的注解
			System.out.println("id:"+testAnnotation.id());
			System.out.println("msg:"+testAnnotation.msg());
		}
		
		
		try {
			Field a = Test.class.getDeclaredField("a");
			a.setAccessible(true);
			//获取一个成员变量上的注解
			Check check = a.getAnnotation(Check.class);
			
			if ( check != null ) {
				System.out.println("check value:"+check.value());
			}
			
			Method testMethod = Test.class.getDeclaredMethod("testMethod");
			
			if ( testMethod != null ) {
				// 获取方法中的注解
				Annotation[] ans = testMethod.getAnnotations();
				for( int i = 0;i < ans.length;i++) {
					System.out.println("method testMethod annotation:"+ans[i].annotationType().getSimpleName());
				}
			}
		} catch (NoSuchFieldException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e.getMessage());
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e.getMessage());
		} catch (NoSuchMethodException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			System.out.println(e.getMessage());
		}
		
	}

}
}
```

想在运行时提取注解必须加上@Retention(RetentionPolicy.RUNTIME)

## 注解的使用场景

注解的用处：

- 提供信息给编译器：编译器可以利用注解来探测错误和警告信息
- 编译阶段时的处理：软件工具可以用来利用注解信息生成代码、Html文档或者做其他相应处理。
- 运行时的处理：某些注解可以再程序运行的时候接受代码的提取

注解不是代码本身的一部分。注解主要针对的时编译器和其他工具软件。

# [代理？](https://blog.csdn.net/briblue/article/details/73928350)

## 代理模式

# 并发事务带来的问题

## 脏读（Dirty read）
当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

## 丢失修改（Lost to modify）

指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。

## 不可重复读（Unrepeatableread）

指在一个事务内多次读统一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次数据之间，由于第二个事务的修改导致第一个事务两次读取饿数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。

## 幻读（Phantom read）

与不可重复读类似。发在在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据。在随后的查询中，第一个事务（T1）就会ui发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

**幻读与不可重复读的区别：**不可重复读的中丢失修改，幻读的重点碍于新增或者删除。

